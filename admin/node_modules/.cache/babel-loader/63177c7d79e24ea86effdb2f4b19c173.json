{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"style\"];\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef, unstable_useEnhancedEffect as useEnhancedEffect } from '@mui/material/utils';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridDensityRowHeightSelector } from '../density/densitySelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridEditRowsStateSelector } from '../editRows/gridEditRowsSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { clamp } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../selection/gridSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils'; // Uses binary search to avoid looping through all possible positions\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function binarySearch(offset, positions) {\n  let sliceStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let sliceEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : positions.length;\n\n  if (positions.length <= 0) {\n    return -1;\n  }\n\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const itemOffset = positions[pivot];\n  return offset <= itemOffset ? binarySearch(offset, positions, sliceStart, pivot) : binarySearch(offset, positions, pivot + 1, sliceEnd);\n}\n\nfunction exponentialSearch(offset, positions, index) {\n  let interval = 1;\n\n  while (index < positions.length && positions[index] < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return binarySearch(offset, positions, Math.floor(index / 2), Math.min(index, positions.length));\n}\n\nexport const getRenderableIndexes = _ref2 => {\n  let {\n    firstIndex,\n    lastIndex,\n    buffer,\n    minFirstIndex,\n    maxLastIndex\n  } = _ref2;\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\n};\n\nconst areRenderContextsEqual = (context1, context2) => {\n  if (context1 === context2) {\n    return true;\n  }\n\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n};\n\nexport const useGridVirtualScroller = props => {\n  var _currentPage$range3, _currentPage$range4;\n\n  const apiRef = useGridApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const {\n    ref,\n    disableVirtualization,\n    onRenderZonePositioning,\n    renderZoneMinColumnIndex = 0,\n    renderZoneMaxColumnIndex = visibleColumns.length,\n    getRowProps\n  } = props;\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const renderZoneRef = React.useRef(null);\n  const rootRef = React.useRef(null);\n  const handleRef = useForkRef(ref, rootRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const scrollPosition = React.useRef({\n    top: 0,\n    left: 0\n  });\n  const [containerDimensions, setContainerDimensions] = React.useState({\n    width: null,\n    height: null\n  });\n  const prevTotalWidth = React.useRef(columnsTotalWidth);\n  const getNearestIndexToRender = React.useCallback(offset => {\n    var _currentPage$range, _currentPage$range2;\n\n    const lastMeasuredIndexRelativeToAllRows = apiRef.current.unstable_getLastMeasuredRowIndex();\n    let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n\n    if ((_currentPage$range = currentPage.range) != null && _currentPage$range.lastRowIndex && !allRowsMeasured) {\n      // Check if all rows in this page are already measured\n      allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= currentPage.range.lastRowIndex;\n    }\n\n    const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (((_currentPage$range2 = currentPage.range) == null ? void 0 : _currentPage$range2.firstRowIndex) || 0), 0, rowsMeta.positions.length);\n\n    if (allRowsMeasured || rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n      // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n      // were measured, then use a binary search because it's faster.\n      return binarySearch(offset, rowsMeta.positions);\n    } // Otherwise, use an exponential search.\n    // If rows have \"auto\" as height, their positions will be based on estimated heights.\n    // In this case, we can skip several steps until we find a position higher than the offset.\n    // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n\n    return exponentialSearch(offset, rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage);\n  }, [apiRef, (_currentPage$range3 = currentPage.range) == null ? void 0 : _currentPage$range3.firstRowIndex, (_currentPage$range4 = currentPage.range) == null ? void 0 : _currentPage$range4.lastRowIndex, rowsMeta.positions]);\n  const computeRenderContext = React.useCallback(() => {\n    if (disableVirtualization) {\n      return {\n        firstRowIndex: 0,\n        lastRowIndex: currentPage.rows.length,\n        firstColumnIndex: 0,\n        lastColumnIndex: visibleColumns.length\n      };\n    }\n\n    const {\n      top,\n      left\n    } = scrollPosition.current; // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n\n    const firstRowIndex = Math.min(getNearestIndexToRender(top), rowsMeta.positions.length - 1);\n    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getNearestIndexToRender(top + containerDimensions.height);\n    let hasRowWithAutoHeight = false;\n    let firstColumnIndex = 0;\n    let lastColumnIndex = columnPositions.length;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: firstRowIndex,\n      lastIndex: lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n\n    for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n      const row = currentPage.rows[i];\n      hasRowWithAutoHeight = apiRef.current.unstable_rowHasAutoHeight(row.id);\n    }\n\n    if (!hasRowWithAutoHeight) {\n      firstColumnIndex = binarySearch(left, columnPositions);\n      lastColumnIndex = binarySearch(left + containerDimensions.width, columnPositions);\n    }\n\n    return {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }, [disableVirtualization, getNearestIndexToRender, rowsMeta.positions.length, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef, containerDimensions]);\n  useEnhancedEffect(() => {\n    if (disableVirtualization) {\n      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;\n    } else {\n      // TODO a scroll reset should not be necessary\n      rootRef.current.scrollLeft = 0;\n      rootRef.current.scrollTop = 0;\n    }\n  }, [disableVirtualization]);\n  useEnhancedEffect(() => {\n    setContainerDimensions({\n      width: rootRef.current.clientWidth,\n      height: rootRef.current.clientHeight\n    });\n  }, [rowsMeta.currentPageTotalHeight]);\n  const handleResize = React.useCallback(params => {\n    setContainerDimensions({\n      width: params.width,\n      height: params.height\n    });\n  }, []);\n  useGridApiEventHandler(apiRef, 'resize', handleResize);\n  const updateRenderZonePosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const [initialFirstColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: renderZoneMinColumnIndex,\n      maxLastIndex: renderZoneMaxColumnIndex,\n      buffer: rootProps.columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\n    const left = gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\n\n    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;\n\n    if (typeof onRenderZonePositioning === 'function') {\n      onRenderZonePositioning({\n        top,\n        left\n      });\n    }\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer]);\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (prevRenderContext.current && areRenderContextsEqual(nextRenderContext, prevRenderContext.current)) {\n      updateRenderZonePosition(nextRenderContext);\n      return;\n    }\n\n    setRenderContext(nextRenderContext);\n    updateRenderZonePosition(nextRenderContext);\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    apiRef.current.publishEvent('renderedRowsIntervalChange', {\n      firstRowToRender,\n      lastRowToRender\n    });\n    prevRenderContext.current = nextRenderContext;\n  }, [apiRef, setRenderContext, prevRenderContext, currentPage.rows.length, rootProps.rowBuffer, updateRenderZonePosition]);\n  useEnhancedEffect(() => {\n    if (containerDimensions.width == null) {\n      return;\n    }\n\n    const initialRenderContext = computeRenderContext();\n    updateRenderContext(initialRenderContext);\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const params = {\n      top,\n      left,\n      renderContext: initialRenderContext\n    };\n    apiRef.current.publishEvent('rowsScroll', params);\n  }, [apiRef, computeRenderContext, containerDimensions.width, updateRenderContext]);\n\n  const handleScroll = event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    scrollPosition.current.top = scrollTop;\n    scrollPosition.current.left = scrollLeft; // On iOS and macOS, negative offsets are possible when swiping past the start\n\n    if (scrollLeft < 0 || scrollTop < 0 || !prevRenderContext.current) {\n      return;\n    } // When virtualization is disabled, the context never changes during scroll\n\n\n    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\n    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\n    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\n    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\n    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\n    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth; // TODO v6: rename event to a wider name, it's not only fired for row scrolling\n\n    apiRef.current.publishEvent('rowsScroll', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\n    }, event);\n\n    if (shouldSetState) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      prevTotalWidth.current = columnsTotalWidth;\n    }\n  };\n\n  const handleWheel = event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  };\n\n  const handleTouchMove = event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  };\n\n  const getRows = function () {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      renderContext\n    };\n    const {\n      renderContext: nextRenderContext,\n      minFirstColumn = renderZoneMinColumnIndex,\n      maxLastColumn = renderZoneMaxColumnIndex,\n      availableSpace = containerDimensions.width,\n      rowIndexOffset = 0,\n      position = 'center'\n    } = params;\n\n    if (!nextRenderContext || availableSpace == null) {\n      return null;\n    }\n\n    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\n    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rowBuffer\n    });\n    const renderedRows = [];\n\n    if (params.rows) {\n      params.rows.forEach(row => {\n        renderedRows.push(row);\n        apiRef.current.unstable_calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      });\n    } else {\n      if (!currentPage.range) {\n        return null;\n      }\n\n      for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n        const row = currentPage.rows[i];\n        renderedRows.push(row);\n        apiRef.current.unstable_calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      }\n    }\n\n    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: minFirstColumn,\n      maxLastIndex: maxLastColumn,\n      buffer: columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    const rows = [];\n\n    for (let i = 0; i < renderedRows.length; i += 1) {\n      var _currentPage$range5, _rootProps$components;\n\n      const {\n        id,\n        model\n      } = renderedRows[i];\n      const lastVisibleRowIndex = firstRowToRender + i === currentPage.rows.length - 1;\n      const baseRowHeight = !apiRef.current.unstable_rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n\n      rows.push( /*#__PURE__*/_jsx(rootProps.components.Row, _extends({\n        row: model,\n        rowId: id,\n        rowHeight: baseRowHeight,\n        cellFocus: cellFocus // TODO move to inside the row\n        ,\n        cellTabIndex: cellTabIndex // TODO move to inside the row\n        ,\n        editRowsState: editRowsState // TODO move to inside the row\n        ,\n        renderedColumns: renderedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnToRender: firstColumnToRender,\n        lastColumnToRender: lastColumnToRender,\n        selected: isSelected,\n        index: rowIndexOffset + ((currentPage == null ? void 0 : (_currentPage$range5 = currentPage.range) == null ? void 0 : _currentPage$range5.firstRowIndex) || 0) + firstRowToRender + i,\n        containerWidth: availableSpace,\n        isLastVisible: lastVisibleRowIndex,\n        position: position\n      }, typeof getRowProps === 'function' ? getRowProps(id, model) : {}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.row), id));\n    }\n\n    return rows;\n  };\n\n  const needsHorizontalScrollbar = containerDimensions.width && columnsTotalWidth > containerDimensions.width;\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);\n    let shouldExtendContent = false;\n\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\n      shouldExtendContent = true;\n    }\n\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height,\n      minHeight: shouldExtendContent ? '100%' : 'auto'\n    };\n\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\n      size.height = 2 * rowHeight; // Give room to show the overlay when there's no row.\n    }\n\n    return size;\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, currentPage.rows.length, needsHorizontalScrollbar, rootProps.autoHeight, rowHeight]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\n    contentSize.height = 2 * rowHeight; // Give room to show the overlay when there no rows.\n  }\n\n  const rootStyle = {};\n\n  if (!needsHorizontalScrollbar) {\n    rootStyle.overflowX = 'hidden';\n  }\n\n  if (rootProps.autoHeight) {\n    rootStyle.overflowY = 'hidden';\n  }\n\n  const getRenderContext = React.useCallback(() => {\n    return prevRenderContext.current;\n  }, []);\n  apiRef.current.unstable_getRenderContext = getRenderContext;\n  return {\n    renderContext,\n    updateRenderZonePosition,\n    getRows,\n    getRootProps: function () {\n      let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      let {\n        style = {}\n      } = _ref,\n          other = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      return _extends({\n        ref: handleRef,\n        onScroll: handleScroll,\n        onWheel: handleWheel,\n        onTouchMove: handleTouchMove,\n        style: _extends({}, style, rootStyle)\n      }, other);\n    },\n    getContentProps: function () {\n      let {\n        style = {}\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        style: _extends({}, style, contentSize)\n      };\n    },\n    getRenderZoneProps: () => ({\n      ref: renderZoneRef\n    })\n  };\n};","map":{"version":3,"sources":["C:/Users/daksh/Desktop/Booking/admin/node_modules/@mui/x-data-grid/hooks/features/virtualization/useGridVirtualScroller.js"],"names":["_objectWithoutPropertiesLoose","_extends","_excluded","React","ReactDOM","useForkRef","unstable_useEnhancedEffect","useEnhancedEffect","useGridApiContext","useGridRootProps","useGridSelector","gridVisibleColumnDefinitionsSelector","gridColumnsTotalWidthSelector","gridColumnPositionsSelector","gridDensityRowHeightSelector","gridFocusCellSelector","gridTabIndexCellSelector","gridEditRowsStateSelector","useGridVisibleRows","useGridApiEventHandler","clamp","selectedIdsLookupSelector","gridRowsMetaSelector","getFirstNonSpannedColumnToRender","jsx","_jsx","binarySearch","offset","positions","sliceStart","sliceEnd","length","pivot","Math","floor","itemOffset","exponentialSearch","index","interval","min","getRenderableIndexes","firstIndex","lastIndex","buffer","minFirstIndex","maxLastIndex","areRenderContextsEqual","context1","context2","firstRowIndex","lastRowIndex","firstColumnIndex","lastColumnIndex","useGridVirtualScroller","props","_currentPage$range3","_currentPage$range4","apiRef","rootProps","visibleColumns","ref","disableVirtualization","onRenderZonePositioning","renderZoneMinColumnIndex","renderZoneMaxColumnIndex","getRowProps","columnPositions","columnsTotalWidth","rowHeight","cellFocus","cellTabIndex","rowsMeta","editRowsState","selectedRowsLookup","currentPage","renderZoneRef","useRef","rootRef","handleRef","renderContext","setRenderContext","useState","prevRenderContext","scrollPosition","top","left","containerDimensions","setContainerDimensions","width","height","prevTotalWidth","getNearestIndexToRender","useCallback","_currentPage$range","_currentPage$range2","lastMeasuredIndexRelativeToAllRows","current","unstable_getLastMeasuredRowIndex","allRowsMeasured","Infinity","range","lastMeasuredIndexRelativeToCurrentPage","computeRenderContext","rows","autoHeight","hasRowWithAutoHeight","firstRowToRender","lastRowToRender","rowBuffer","i","row","unstable_rowHasAutoHeight","id","style","transform","scrollLeft","scrollTop","clientWidth","clientHeight","currentPageTotalHeight","handleResize","params","updateRenderZonePosition","nextRenderContext","initialFirstColumnToRender","columnBuffer","firstColumnToRender","visibleRows","state","updateRenderContext","publishEvent","initialRenderContext","handleScroll","event","currentTarget","topRowsScrolledSincePreviousRender","abs","bottomRowsScrolledSincePreviousRender","topColumnsScrolledSincePreviousRender","bottomColumnsScrolledSincePreviousRender","shouldSetState","rowThreshold","columnThreshold","flushSync","handleWheel","handleTouchMove","getRows","minFirstColumn","maxLastColumn","availableSpace","rowIndexOffset","position","renderedRows","forEach","push","unstable_calculateColSpan","rowId","columns","lastColumnToRender","renderedColumns","slice","_currentPage$range5","_rootProps$components","model","lastVisibleRowIndex","baseRowHeight","unstable_getRowHeight","isSelected","isRowSelectable","components","Row","selected","containerWidth","isLastVisible","componentsProps","needsHorizontalScrollbar","contentSize","useMemo","max","shouldExtendContent","size","minHeight","useEffect","rootStyle","overflowX","overflowY","getRenderContext","unstable_getRenderContext","getRootProps","_ref","other","onScroll","onWheel","onTouchMove","getContentProps","getRenderZoneProps"],"mappings":"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","sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"style\"];\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef, unstable_useEnhancedEffect as useEnhancedEffect } from '@mui/material/utils';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridDensityRowHeightSelector } from '../density/densitySelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridEditRowsStateSelector } from '../editRows/gridEditRowsSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { clamp } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../selection/gridSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils'; // Uses binary search to avoid looping through all possible positions\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function binarySearch(offset, positions, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const itemOffset = positions[pivot];\n  return offset <= itemOffset ? binarySearch(offset, positions, sliceStart, pivot) : binarySearch(offset, positions, pivot + 1, sliceEnd);\n}\n\nfunction exponentialSearch(offset, positions, index) {\n  let interval = 1;\n\n  while (index < positions.length && positions[index] < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return binarySearch(offset, positions, Math.floor(index / 2), Math.min(index, positions.length));\n}\n\nexport const getRenderableIndexes = ({\n  firstIndex,\n  lastIndex,\n  buffer,\n  minFirstIndex,\n  maxLastIndex\n}) => {\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\n};\n\nconst areRenderContextsEqual = (context1, context2) => {\n  if (context1 === context2) {\n    return true;\n  }\n\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n};\n\nexport const useGridVirtualScroller = props => {\n  var _currentPage$range3, _currentPage$range4;\n\n  const apiRef = useGridApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const {\n    ref,\n    disableVirtualization,\n    onRenderZonePositioning,\n    renderZoneMinColumnIndex = 0,\n    renderZoneMaxColumnIndex = visibleColumns.length,\n    getRowProps\n  } = props;\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const renderZoneRef = React.useRef(null);\n  const rootRef = React.useRef(null);\n  const handleRef = useForkRef(ref, rootRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const scrollPosition = React.useRef({\n    top: 0,\n    left: 0\n  });\n  const [containerDimensions, setContainerDimensions] = React.useState({\n    width: null,\n    height: null\n  });\n  const prevTotalWidth = React.useRef(columnsTotalWidth);\n  const getNearestIndexToRender = React.useCallback(offset => {\n    var _currentPage$range, _currentPage$range2;\n\n    const lastMeasuredIndexRelativeToAllRows = apiRef.current.unstable_getLastMeasuredRowIndex();\n    let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n\n    if ((_currentPage$range = currentPage.range) != null && _currentPage$range.lastRowIndex && !allRowsMeasured) {\n      // Check if all rows in this page are already measured\n      allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= currentPage.range.lastRowIndex;\n    }\n\n    const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (((_currentPage$range2 = currentPage.range) == null ? void 0 : _currentPage$range2.firstRowIndex) || 0), 0, rowsMeta.positions.length);\n\n    if (allRowsMeasured || rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n      // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n      // were measured, then use a binary search because it's faster.\n      return binarySearch(offset, rowsMeta.positions);\n    } // Otherwise, use an exponential search.\n    // If rows have \"auto\" as height, their positions will be based on estimated heights.\n    // In this case, we can skip several steps until we find a position higher than the offset.\n    // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n\n    return exponentialSearch(offset, rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage);\n  }, [apiRef, (_currentPage$range3 = currentPage.range) == null ? void 0 : _currentPage$range3.firstRowIndex, (_currentPage$range4 = currentPage.range) == null ? void 0 : _currentPage$range4.lastRowIndex, rowsMeta.positions]);\n  const computeRenderContext = React.useCallback(() => {\n    if (disableVirtualization) {\n      return {\n        firstRowIndex: 0,\n        lastRowIndex: currentPage.rows.length,\n        firstColumnIndex: 0,\n        lastColumnIndex: visibleColumns.length\n      };\n    }\n\n    const {\n      top,\n      left\n    } = scrollPosition.current; // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n\n    const firstRowIndex = Math.min(getNearestIndexToRender(top), rowsMeta.positions.length - 1);\n    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getNearestIndexToRender(top + containerDimensions.height);\n    let hasRowWithAutoHeight = false;\n    let firstColumnIndex = 0;\n    let lastColumnIndex = columnPositions.length;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: firstRowIndex,\n      lastIndex: lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n\n    for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n      const row = currentPage.rows[i];\n      hasRowWithAutoHeight = apiRef.current.unstable_rowHasAutoHeight(row.id);\n    }\n\n    if (!hasRowWithAutoHeight) {\n      firstColumnIndex = binarySearch(left, columnPositions);\n      lastColumnIndex = binarySearch(left + containerDimensions.width, columnPositions);\n    }\n\n    return {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }, [disableVirtualization, getNearestIndexToRender, rowsMeta.positions.length, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef, containerDimensions]);\n  useEnhancedEffect(() => {\n    if (disableVirtualization) {\n      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;\n    } else {\n      // TODO a scroll reset should not be necessary\n      rootRef.current.scrollLeft = 0;\n      rootRef.current.scrollTop = 0;\n    }\n  }, [disableVirtualization]);\n  useEnhancedEffect(() => {\n    setContainerDimensions({\n      width: rootRef.current.clientWidth,\n      height: rootRef.current.clientHeight\n    });\n  }, [rowsMeta.currentPageTotalHeight]);\n  const handleResize = React.useCallback(params => {\n    setContainerDimensions({\n      width: params.width,\n      height: params.height\n    });\n  }, []);\n  useGridApiEventHandler(apiRef, 'resize', handleResize);\n  const updateRenderZonePosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const [initialFirstColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: renderZoneMinColumnIndex,\n      maxLastIndex: renderZoneMaxColumnIndex,\n      buffer: rootProps.columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\n    const left = gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\n\n    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;\n\n    if (typeof onRenderZonePositioning === 'function') {\n      onRenderZonePositioning({\n        top,\n        left\n      });\n    }\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer]);\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (prevRenderContext.current && areRenderContextsEqual(nextRenderContext, prevRenderContext.current)) {\n      updateRenderZonePosition(nextRenderContext);\n      return;\n    }\n\n    setRenderContext(nextRenderContext);\n    updateRenderZonePosition(nextRenderContext);\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    apiRef.current.publishEvent('renderedRowsIntervalChange', {\n      firstRowToRender,\n      lastRowToRender\n    });\n    prevRenderContext.current = nextRenderContext;\n  }, [apiRef, setRenderContext, prevRenderContext, currentPage.rows.length, rootProps.rowBuffer, updateRenderZonePosition]);\n  useEnhancedEffect(() => {\n    if (containerDimensions.width == null) {\n      return;\n    }\n\n    const initialRenderContext = computeRenderContext();\n    updateRenderContext(initialRenderContext);\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const params = {\n      top,\n      left,\n      renderContext: initialRenderContext\n    };\n    apiRef.current.publishEvent('rowsScroll', params);\n  }, [apiRef, computeRenderContext, containerDimensions.width, updateRenderContext]);\n\n  const handleScroll = event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    scrollPosition.current.top = scrollTop;\n    scrollPosition.current.left = scrollLeft; // On iOS and macOS, negative offsets are possible when swiping past the start\n\n    if (scrollLeft < 0 || scrollTop < 0 || !prevRenderContext.current) {\n      return;\n    } // When virtualization is disabled, the context never changes during scroll\n\n\n    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\n    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\n    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\n    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\n    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\n    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth; // TODO v6: rename event to a wider name, it's not only fired for row scrolling\n\n    apiRef.current.publishEvent('rowsScroll', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\n    }, event);\n\n    if (shouldSetState) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      prevTotalWidth.current = columnsTotalWidth;\n    }\n  };\n\n  const handleWheel = event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  };\n\n  const handleTouchMove = event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  };\n\n  const getRows = (params = {\n    renderContext\n  }) => {\n    const {\n      renderContext: nextRenderContext,\n      minFirstColumn = renderZoneMinColumnIndex,\n      maxLastColumn = renderZoneMaxColumnIndex,\n      availableSpace = containerDimensions.width,\n      rowIndexOffset = 0,\n      position = 'center'\n    } = params;\n\n    if (!nextRenderContext || availableSpace == null) {\n      return null;\n    }\n\n    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\n    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rowBuffer\n    });\n    const renderedRows = [];\n\n    if (params.rows) {\n      params.rows.forEach(row => {\n        renderedRows.push(row);\n        apiRef.current.unstable_calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      });\n    } else {\n      if (!currentPage.range) {\n        return null;\n      }\n\n      for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n        const row = currentPage.rows[i];\n        renderedRows.push(row);\n        apiRef.current.unstable_calculateColSpan({\n          rowId: row.id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n      }\n    }\n\n    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: minFirstColumn,\n      maxLastIndex: maxLastColumn,\n      buffer: columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    const rows = [];\n\n    for (let i = 0; i < renderedRows.length; i += 1) {\n      var _currentPage$range5, _rootProps$components;\n\n      const {\n        id,\n        model\n      } = renderedRows[i];\n      const lastVisibleRowIndex = firstRowToRender + i === currentPage.rows.length - 1;\n      const baseRowHeight = !apiRef.current.unstable_rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n\n      rows.push( /*#__PURE__*/_jsx(rootProps.components.Row, _extends({\n        row: model,\n        rowId: id,\n        rowHeight: baseRowHeight,\n        cellFocus: cellFocus // TODO move to inside the row\n        ,\n        cellTabIndex: cellTabIndex // TODO move to inside the row\n        ,\n        editRowsState: editRowsState // TODO move to inside the row\n        ,\n        renderedColumns: renderedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnToRender: firstColumnToRender,\n        lastColumnToRender: lastColumnToRender,\n        selected: isSelected,\n        index: rowIndexOffset + ((currentPage == null ? void 0 : (_currentPage$range5 = currentPage.range) == null ? void 0 : _currentPage$range5.firstRowIndex) || 0) + firstRowToRender + i,\n        containerWidth: availableSpace,\n        isLastVisible: lastVisibleRowIndex,\n        position: position\n      }, typeof getRowProps === 'function' ? getRowProps(id, model) : {}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.row), id));\n    }\n\n    return rows;\n  };\n\n  const needsHorizontalScrollbar = containerDimensions.width && columnsTotalWidth > containerDimensions.width;\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);\n    let shouldExtendContent = false;\n\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\n      shouldExtendContent = true;\n    }\n\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height,\n      minHeight: shouldExtendContent ? '100%' : 'auto'\n    };\n\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\n      size.height = 2 * rowHeight; // Give room to show the overlay when there's no row.\n    }\n\n    return size;\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, currentPage.rows.length, needsHorizontalScrollbar, rootProps.autoHeight, rowHeight]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\n    contentSize.height = 2 * rowHeight; // Give room to show the overlay when there no rows.\n  }\n\n  const rootStyle = {};\n\n  if (!needsHorizontalScrollbar) {\n    rootStyle.overflowX = 'hidden';\n  }\n\n  if (rootProps.autoHeight) {\n    rootStyle.overflowY = 'hidden';\n  }\n\n  const getRenderContext = React.useCallback(() => {\n    return prevRenderContext.current;\n  }, []);\n  apiRef.current.unstable_getRenderContext = getRenderContext;\n  return {\n    renderContext,\n    updateRenderZonePosition,\n    getRows,\n    getRootProps: (_ref = {}) => {\n      let {\n        style = {}\n      } = _ref,\n          other = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      return _extends({\n        ref: handleRef,\n        onScroll: handleScroll,\n        onWheel: handleWheel,\n        onTouchMove: handleTouchMove,\n        style: _extends({}, style, rootStyle)\n      }, other);\n    },\n    getContentProps: ({\n      style = {}\n    } = {}) => ({\n      style: _extends({}, style, contentSize)\n    }),\n    getRenderZoneProps: () => ({\n      ref: renderZoneRef\n    })\n  };\n};"]},"metadata":{},"sourceType":"module"}